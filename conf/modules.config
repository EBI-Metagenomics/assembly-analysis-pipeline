/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Config file for defining DSL2 per module options and publishing paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Available keys to override module options:
        ext.args   = Additional arguments appended to command in module.
        ext.args2  = Second set of arguments appended to command in module (multi-tool modules).
        ext.args3  = Third set of arguments appended to command in module (multi-tool modules).
        ext.prefix = File name prefix for output files.
----------------------------------------------------------------------------------------
*/

process {

    withName: MULTIQC {
        ext.args   = { params.multiqc_title ? "--title \"${params.multiqc_title}\"" : '' }
        publishDir = [
            path: { "${params.outdir}/multiqc" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    /* Most of the pipeline only analyzes contigs >= this threshold, but BGC uses a threshold size. */
    withName: FILTER_ASSEMBLY {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/qc" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> {
                    if (filename.equals('versions.yml')) {
                        return null
                    }
                    return "${meta.id}_filtered_contigs.fasta.gz"
                }
            },
        ]
    }

    withName: PRE_FILTER_STATS {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/qc" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> {
                    if (filename.equals('versions.yml')) {
                        return null
                    }
                    return "${meta.id}_pre_filter_stats.tsv.gz"
                }
            },
        ]
    }

    withName: POST_FILTER_STATS {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/qc" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> {
                    if (filename.equals('versions.yml')) {
                        return null
                    }
                    return "${meta.id}_post_filter_stats.tsv.gz"
                }
            },
        ]
    }

    withName: SEQKIT_SPLIT2 {
        // We are tweaking the prefix to prevent names like <assembly_id>.part_001.gz to be used
        // in favour of <assembly_id>_part_001.gz which is more file name parsing friendly
        // which helps when concatenating chunked post-processed fasta files, such as the results of interposcan
        ext.args = { "--by-length-prefix ${meta.id}_" }
    }

    withName: PYRODIGAL {
        ext.args = "-p meta"
    }

    withName: COMBINEDGENECALLER_MERGE {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> {
                    if (filename.equals('versions.yml')) {
                        return null
                    }
                    if (filename.contains("faa.gz")) {
                        return "${meta.id}_predicted_cds.faa.gz"
                    }
                    if (filename.contains("ffn.gz")) {
                        return "${meta.id}_predicted_orf.ffn.gz"
                    }
                    if (filename.contains("gff.gz")) {
                        return "${meta.id}_predicted_cds.gff.gz"
                    }
                }
            },
        ]
    }

    // Taxonomy assignation //
    withName: DIAMOND_BLASTP {
       ext.args = "--top 11"
    }
    withName: CATPACK_ADDNAMES {
        ext.args = "--only_official"
    }

    // TODO: adjust this in nf-modules - rename output and compress tsv
    withName: CATPACK_CONTIGS {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/taxonomy" },
            mode: params.publish_dir_mode,
            pattern: "*contig2classification.txt.gz",
            saveAs: { "${meta.id}_contigs_taxonomy.tsv.gz" }
        ]
    }

    withName: KRONA_KTIMPORTTEXT {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/taxonomy" },
            mode: params.publish_dir_mode,
            pattern: "*.html"
        ]
    }

    withName: TABIX_BGZIP_KRONATXT {
        ext.prefix = { "${meta.id}_taxonomy_summary" }
        ext.args = { "--index --index-name ${meta.id}_taxonomy_summary.gz.gzi" }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/taxonomy" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: SEQKIT_SEQ_BGC {
        ext.args = "--min-len ${params.bgc_min_contig_length}"
        ext.prefix = { "${meta.id}_bgc_len_filtered" }
    }

    withName: HMMSEARCH_KOFAMS {
        cpus   = { 4     * task.attempt }
        memory = { 16.GB  * task.attempt }
        time   = { 16.h   * task.attempt }
        // We override the prefix of the output here because the input is chunked and joined with CAT_CAT
        // and to avoid naming collisions we use the name of the input (which comes from SEQKIT_SPLIT2) that
        // contains the chunk part in it.
        ext.prefix = { "${seqdb.simpleName}" }
    }

    withName: KEGG_ORTHOLOGS_SUMMARY {
        cpus   = { 4     * task.attempt }
        memory = { 6.GB  * task.attempt }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/kegg" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: KEGGPATHWAYSCOMPLETENESS {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/pathways-and-systems/kegg" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: TABIX_BGZIP_KEGGPATHWAYSCOMPLETENESS {
        ext.prefix = { "${meta.id}_summary_kegg_pathways" }
        ext.args = { "--index --index-name ${meta.id}_summary_kegg_pathways.tsv.gz.gzi" }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/pathways-and-systems/kegg" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: TABIX_BGZIP_RHEADCHEBI {
        ext.prefix = { "${meta.id}_rhea2proteins" }
        ext.args = { "--index --index-name ${meta.id}_rhea2proteins.tsv.gz.gzi" }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/rhea-reactions" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: EGGNOGMAPPER_ORTHOLOGS {
        cpus   = 16
        memory = 50.GB
        // We override the prefix of the output here because the input is chunked and joined with CAT_CAT
        // and to avoid naming collisions we use the name of the input (which comes from SEQKIT_SPLIT2) that
        // contains the chunk part in it.
        ext.prefix = { "${fasta.simpleName}" }
        // No headers on outputs to make it easier to concatenate
        ext.args = "--no_file_comments"
    }

    withName: CONCATENATE_EGGNOGMAPPER_ORTHOLOGOUS {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/eggnog" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
        ext.prefix = { "${meta.id}_emapper_seed_orthologous.tsv.gz" }
    }

    withName: EGGNOGMAPPER_ANNOTATIONS {
        cpus   = 16
        memory = 50.GB
        // We override the prefix of the output here because the input is chunked and joined with CAT_CAT
        // and to avoid naming collisions we use the name of the input (which comes from SEQKIT_SPLIT2) that
        // contains the chunk part in it.
        ext.prefix = { "${annotation_hit_table.simpleName}_annotations" }
        // No headers on outputs to make it easier to concatenate
        ext.args = "--no_file_comments"
    }

    withName: CONCATENATE_EGGNOGMAPPER_ANNOTATIONS {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/eggnog" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
        ext.prefix = { "${meta.id}_emapper_annotations.tsv.gz" }
    }

    withName: INTERPROSCAN {
        cpus   = 16
        memory = { 12.GB * task.attempt }
        ext.args =
            "--iprlookup " +
            "--goterms " +
            "--applications " + [
                "TIGRFAM",
                "SFLD",
                "SUPERFAMILY",
                "Gene3D",
                "Hamap",
                "Coils",
                "SMART",
                "CDD",
                "PRINTS",
                "PIRSF",
                "ProSiteProfiles",
                "ProSitePatterns",
                "PfamA",
                "MobiDBLite",
                // "SignalP_GRAM_POSITIVE", TODO: get a license
                // "SignalP_GRAM_NEGATIVE",
                // "SignalP_EUK",
                // "Phobius", TODO: get a license
                // "TMHMM", TODO: get a license
        ].join(",")

        // We override the prefix of the output here because the input is chunked and joined with CAT_CAT
        // and to avoid naming collisions we use the name of the input (which comes from SEQKIT_SPLIT2) that
        // contains the chunk part in it.
        ext.prefix = { "${fasta.simpleName}" }
    }

    withName: CONCATENATE_INTERPROSCAN_TSV {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/interpro" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
        ext.prefix = { "${meta.id}_interproscan.tsv" }
    }

    withName: INTERPRO_SUMMARY {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/interpro" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: PFAM_SUMMARY {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/pfam" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: OWLTOOLS {
        ext.args = '--map2slim'
    }

    withName: TABIX_BGZIP_GO {
        ext.prefix = { "${meta.id}_go_summary" }
        ext.args = { "--index --index-name ${meta.id}_go_summary.tsv.gz.gzi" }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/go" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: TABIX_BGZIP_GOSLIM {
        ext.prefix = { "${meta.id}_goslim_summary" }
        ext.args = { "--index --index-name ${meta.id}_goslim_summary.tsv.gz.gzi" }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/go" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: DBCAN {
        // We need the chunk name here, otherwise the concatenate downstream fails
        ext.prefix = { fasta.simpleName }
        // We run DBCan in cluster mode
        ext.args = { "--cgc_substrate --cluster ${gff.name.replace(".gz", "")}" }
        cpus   = 8
        memory = 10.GB
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/dbcan/${fasta.simpleName}" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> {
                    if ( filename.contains("substrate.out.gz") ) {
                        return "${prefix}_dbcan_substrate.out.gz"
                    }
                    if ( filename.contains("standard.out.gz") ) {
                        return "${prefix}_dbcan_standard.out.gz"
                    }
                    if ( filename.contains("overview.txt.gz") ) {
                        return "${prefix}_dbcan_overview.txt.gz"
                    }
                    if ( filename.contains("cgc.gff.gz") ) {
                        return "${prefix}_dbcan_cgc.gff.gz"
                    }
                }
            }
        ]
    }

    withName: CONCATENATE_DBCAN_GFFS {
        ext.prefix = { "${meta.id}_dbcan_cgc" }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/dbcan" },
            mode: params.publish_dir_mode,
            pattern: "*concatenated.gff",
            saveAs: { "${meta.id}_dbcan_cgc.gff.gz" },
        ]
    }

    withName: CONCATENATE_DBCAN_OVERVIEW {
        ext.prefix = { "${meta.id}_dbcan_overview" }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/functional-annotation/dbcan" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: GENOMEPROPERTIES {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/pathways-and-systems/genome-properties" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
        ext.args = '-all -outfiles table -outfiles web_json -outfiles summary'
    }

    // TODO: Do we want to publish everything?
    withName: ANTISMASH_ANTISMASHLITE {
        // We use the fasta chunk name... ERZXXX_part01.fasta -> ERZXXX_part01. This is to avoid issues downstream
        ext.prefix = { sequence_input.simpleName }
        time   = { 16.h  * task.attempt }
        publishDir = [
            path: { "${params.outdir}/${meta.id}/pathways-and-systems/antismash" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> {
                    if (filename.equals('versions.yml')) {
                        return null
                    }
                    // This is to flatten the results from "{meta.id}/antismash/-files-" to "antismash/-files-"
                    // And to create one folder per chunk
                    return filename.replace("${meta.id}/${sequence_input.simpleName}/", "")
                }
            }
        ]
    }

    withName: SANNTIS {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/pathways-and-systems/sanntis" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    // We can CMSEARCH in hmm only, the covariance mode would take too long
    // TODO: check if the rRNA module is affected by this
    withName: INFERNAL_CMSEARCH {
        // We override the prefix of the output here because the input is chunked and joined with CAT_CAT
        // and to avoid naming collisions we use the name of the input (which comes from SEQKIT_SPLIT2) that
        // contains the chunk part in it.
        ext.prefix = { "${seqdb.simpleName}" }
        ext.args = '--noali --hmmonly -Z 1000 -o /dev/null'
    }

    withName: CONCATENATE_CMSEARCH_DEOVERLAP {
        ext.prefix = { "${meta.id}_cmsearch_deoverlap" }
    }

    withName: CMSEARCHTBLOUTDEOVERLAP {
        // We override the prefix of the output here because the input is chunked and joined with CAT_CAT
        // and to avoid naming collisions we use the name of the input (which comes from SEQKIT_SPLIT2) that
        // contains the chunk part in it.
        ext.prefix = { "${cmsearch_tblout.simpleName}" }
    }

    // TODO: this is testing code //
    withName: "INFERNAL_CMSEARCH|CMSEARCHTBLOUTDEOVERLAP|EASEL_ESLSFETCH" {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/detect_rna" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: '.*:DETECT_RNA:CAT_CAT' {
        ext.prefix = { "${meta.id}_detect_rna_cmsearch_matches" }
    }

    withName: '.*:DETECT_RNA:EASEL_ESLSFETCH' {
        publishDir = [
            path: { "${params.outdir}/${meta.id}/detect_rna" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }
}
